---
title: "Gene Sequence Data for Link Analysis"
author: "Janis Corona"
date: "3/27/2020"
output: html_document
---

This Rmarkdown file will extract the genes having high Copy Number Variants (CNVs) and fold change expression values in their available data. The information is from the previous GEO data sets used earlier, that also had sequence information as well as gene information. These studies having gene sequence information are: [Alzheimer's Disease (AD)](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE109887), [Colon] Cancer(https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE135749), [Stomach cancer](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi), [pancreatic cancer](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE131859), a beadchip study done on [uterine leiomyomas (UL)](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi), and a microarry study done on [uterine leiomyomas (UL)](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi). Once these genes having the most CNVs and fold changes are found, a link network will be built to demonstrate how these genes are linked to any of these diseases if applicable. From the top genes of each disease just listed.
```{r}
library(dplyr)
library(tidyr)
library(DT)
library(visNetwork)
```

The tables being used are from the following disease study files.
- UL_study1_thresholds.csv
- UL_microarray_thresholds.csv
- GastricStomachCancer_Thresholds.csv
- ColonCancerThresholds.csv
- Pancreatic_Cancer_Thresholds.csv
- useableAlzheimerStats.csv

These files will be uploaded to the github folder of files for this Rmarkdown script that creates a link analysis with visNetwork to display the genes associated with certain diseases and if associated with other diseases.

To skip straight through to the section that builds the visual network analysis of genes related to diseases, search for '%^&' or !!!THE BEGINNING of our VISNETWORK!!! within RStudio. About line 870 of this Rmarkdown file.

***
***
***

Uterine leiomyomas Disease data table.
```{r, eval=FALSE}
ULp <- read.delim('GPL21145-48548.txt', sep='\t', comment.char='#',
                 header=TRUE, na.strings=c('',' ', 'NA'))
head(ULp)
```
These two are from the same study with beadchip expressions.
```{r, eval=FALSE}
UL1 <- read.csv('UL_GSE95101_GPL13376_table.csv', sep=',',header=TRUE,
                  na.strings=c('',' ','NA'))
nonUL1 <- read.csv('nonUL_GSE95101_GPL13376_table.csv', sep=',',header=TRUE,
                  na.strings=c('',' ','NA'))
```

These next two are from different studies with beadchip expressions. These have to be merged with the platform ULp we read in a couple Rmarkdown chunks ago.
```{r, eval=FALSE}
UL2 <- read.csv('UL_GSE120854_GPL23767_table.csv', sep=',',header=TRUE,
                  na.strings=c('',' ','NA'))
nonUL2 <- read.csv('nonUL_GSE120854_GPL23767_table.csv', sep=',',header=TRUE,
                  na.strings=c('',' ','NA'))


```

Keep only the columns needed of ULp, ID, SourceSeq, and CHR.There is no gene symbol to bind to this data table platform GPL21145.
```{r, eval=FALSE}
ULP <- ULp %>% select(ID,SourceSeq,CHR)
UL2b <- UL2 %>% select(-X,-SPOT_ID)
nonUL2b <- nonUL2 %>% select(-X,-SPOT_ID)

colnames(UL2b)[2:25] <- paste('UL',colnames(UL2b)[2:25],sep='_')
colnames(nonUL2b)[2:11] <- paste('nonUL', colnames(nonUL2b)[2:11],sep='_')
```


```{r, eval=FALSE}
UL_2study <- merge(UL2b,nonUL2b, by.x='ID', by.y='ID') 

UL_study2 <- merge(ULP, UL_2study, by.x='ID', by.y='ID')
str(UL_study2)
```

Remove the 'null' values that aren't being recognized by the na.strings or complete.cases. And also the numeric gene expression values are being read in as factors. Do this by writing it to csv and reading it back in and declaring 'null' as an na.string.
```{r, eval=FALSE}
write.csv(UL_study2, 'UL_study2.csv', row.names=FALSE)

```

```{r, eval=FALSE}
UL_study2 <- read.csv('UL_study2.csv', sep=',', header=TRUE, na.strings=c('',' ','NA','null'))
str(UL_study2)
```

Thats great that it now recognizes each column as a numeric data type and that the null values are now being recognized as NA.

Now, lets use complete.cases to get only those observations with complete cases and remove the NA values.
```{r, eval=FALSE}
UL_study2_cc <- UL_study2[complete.cases(UL_study2),]

obsRM <- length(UL_study2$ID) - length(UL_study2_cc$ID)

cat('The number of observations removed is: ', obsRM,'.')
```
Its too bad that we cannot really do anything with this data, unless we open up ubuntu Linux and use the 3.4 version of R to use Bioconductor to get the gene names. But we can at least use the sequences to see if there are any with copies. Not necessarily CNVs because they would have to have the gene names to see what insertions, deletions, skips, etc make the gene a CNV. We can always extract what we need from it now, then get the gene information with a VM of Ubuntu, download the R version and use the tutorial (assuming it works exactly as demonstrated) [online](http://www.bioconductor.org/help/course-materials/2017/BioC2017/Day2/Workshops/ELMER/doc/data.html).

The following are the requirements using the above online tutorial:
- R version 3.4.1 (2017-06-30)
- Platform: x86_64-pc-linux-gnu (64-bit)
- Running under: Ubuntu 16.04.2 LTS

So lets get the median and foldchange median values. We also don't have the cytoband location, but we do have the chromosome for this set. 
```{r, eval=FALSE}
row.names(UL_study2_cc) <- UL_study2_cc$ID
```

```{r, eval=FALSE}
ul <- grep('^UL', colnames(UL_study2_cc))
UL2_t <- UL_study2_cc[,ul]
nUL2_t <- UL_study2_cc[,-c(1:3,ul)]
```

Get the row medians of the UL and nonUL 2nd study data.
```{r, eval=FALSE}
UL2_t$UL_Median <- apply(UL2_t,1,median)
nUL2_t$nonUL_Median <- apply(nUL2_t,1,median)

FoldChange_Median_UL_to_nonUL <- UL2_t$UL_Median/nUL2_t$nonUL_Median

UL_study2_cc$FoldChange_Median_UL_to_nonUL <- FoldChange_Median_UL_to_nonUL
```

```{r, eval=FALSE}
UL2_cnv <- UL_study2_cc %>%
  group_by(SourceSeq) %>%
  mutate(Sequence_CNVs = n()) %>%
  select(ID,SourceSeq,Sequence_CNVs, CHR,FoldChange_Median_UL_to_nonUL, everything()) %>%
  ungroup() %>%
  unique()
```

The above has all unique CNVs of the sequences, as should be expected since there was no error making the row names the ID field. This data table of beadchip UL gene expression values has `r length(UL2_cnv$ID)` unique Genotypes, SNPs, or CNVs of genes. Again, the gene information will take some side data wrangling to get for that datasets top fold change and gene CNVs greater than the median value of CNVs.Lets write this to table and remember to use it if possible.
```{r, eval=FALSE}
write.csv(UL2_cnv, 'UL_study2_needsGeneData.csv', row.names=FALSE)
```

***

Now lets get to the first study of UL gene expression data that we can use to add to our network analysis of genes related to diseases. These two tables are the UL1 and nonUL1 tables.
```{r, eval=FALSE}
nonUL1b <- nonUL1 %>% select(Symbol,SEQUENCE,Chromosome,Cytoband,GSM2496194:GSM2496222)
UL1b <- UL1 %>% select(Symbol,SEQUENCE,Chromosome,Cytoband,GSM2496185:GSM2496220)
colnames(nonUL1b)[5:22] <- paste('nonUL',colnames(nonUL1b)[5:22],sep='_')
colnames(UL1b)[5:24] <- paste('UL',colnames(UL1b)[5:24],sep='_')

```

Add the Median fields to each table.
```{r, eval=FALSE}

UL1c <- UL1b[,5:24]
nUL1c <- nonUL1b[,5:22]

UL1c$UL1_Median <- apply(UL1c,1,median)
nUL1c$nonUL1_Median <- apply(nUL1c,1,median)

FC <- UL1c$UL1_Median/nUL1c$nonUL1_Median

mUL1 <- UL1b[,1:4]
UL_study1 <- cbind(mUL1,UL1c,nUL1c)

UL_study1$FoldChange_Median_UL1_to_nonUL1 <- FC

UL_study1b <- UL_study1 %>% select(Symbol,SEQUENCE,Chromosome,Cytoband,
                                   FoldChange_Median_UL1_to_nonUL1,
                                   UL1_Median,nonUL1_Median,
                                   everything())
```


There are some missing values in the chromosome and cytoband fields, but we don't need to omit them yet.
```{r, eval=FALSE}
colSums(is.na(UL_study1b))
```
The above shows that there aren't any missing values in the samples or the sequence fields, but there are some in the gene symbol, chromosome, and cytoband fields.

Lets get the CNVs of the genes now, but remove the NAs from the Symbol field first.
```{r, eval=FALSE}
UL_study1b2 <- UL_study1b[complete.cases(UL_study1b$Symbol),]
UL_study1_cnv <- UL_study1b2 %>%
  group_by(Symbol) %>%
  mutate(Symbol_CNVs = n()) %>%
  select(Symbol,Symbol_CNVs,everything()) %>%
  ungroup() %>%
  unique()
```

Lets look at what we have for our first few fields and the values.
```{r, eval=FALSE}
head(UL_study1_cnv[,1:6])
```

This is going to grab our target genes for those genes that have a CNV gene count greater than the top 90th percentile and also is either of the bottom 5th percentile or top 95th percentile for fold change median values of UL to nonUL gene expression values.
```{r, eval=FALSE}
UL_study1_thresholds <- subset(UL_study1_cnv, 
                          UL_study1_cnv$Symbol_CNVs > quantile(UL_study1_cnv$Symbol_CNVs,.9) &
                          (UL_study1_cnv$FoldChange_Median_UL1_to_nonUL1 < 
                            quantile(UL_study1_cnv$FoldChange_Median_UL1_to_nonUL1,.05) |
                          UL_study1_cnv$FoldChange_Median_UL1_to_nonUL1 > 
                            quantile(UL_study1_cnv$FoldChange_Median_UL1_to_nonUL1,.95))
                        )

```


Lets now order this table by CNV and Fold Change values.
```{r, eval=FALSE}
UL_study1_ordered <- UL_study1_thresholds[with(UL_study1_thresholds,
                        order(Symbol_CNVs,FoldChange_Median_UL1_to_nonUL1,
                              decreasing=TRUE)),]
```


Lets take a look at the top few rows and first few columns of this table of threshold value target genes for UL.
```{r, eval=FALSE}
head(UL_study1_ordered[,1:7])
```

The table is ordered by CNVs first then by fold change values within the top CNVs. Lets write this to csv and use it later for our visNetwork. So far, it looks like either the Chromosome or the cytoband could be used for location of the nodes. But we could also group the genes by link to gene disease networks, gene networks, or anything else we get ideas about later. 
```{r, eval=FALSE}
write.csv(UL_study1_ordered,'UL_study1_thresholds.csv',row.names=FALSE)
```

***
UL microarray study
Uterine leiomyomas Disease data table (microarray data).
These two are from the same study with microarray expressions.
```{r, eval=FALSE}
UL1 <- read.csv('UL_GSE68295_GPL6480_table.csv', sep=',',header=TRUE,
                  na.strings=c('',' ','NA'))
nonUL1 <- read.csv('nonUL_GSE68295_GPL6480_table.csv', sep=',',header=TRUE,
                  na.strings=c('',' ','NA'))
```

```{r, eval=FALSE}
colnames(UL1)
colnames(nonUL1)
```

Lets keep only the columns interested in. Those are 
```{r, eval=FALSE}
nonUL1b <- nonUL1 %>% select(GENE_SYMBOL,SEQUENCE,CYTOBAND,GSM1667144:GSM1667146)
UL1b <- UL1 %>% select(GENE_SYMBOL,SEQUENCE,CYTOBAND,GSM1667147:GSM1667149)


colnames(nonUL1b)[4:6] <- paste('nonUL',colnames(nonUL1b)[4:6],sep='_')
colnames(UL1b)[4:6] <- paste('UL',colnames(UL1b)[4:6],sep='_')

```

Add the Median fields to each table.
```{r, eval=FALSE}

UL1c <- UL1b[,4:6]
nUL1c <- nonUL1b[,4:6]

UL1c$UL1_MedianArray <- apply(UL1c,1,median)
nUL1c$nonUL1_MedianArray <- apply(nUL1c,1,median)

FC <- UL1c$UL1_MedianArray/nUL1c$nonUL1_MedianArray

mUL1 <- UL1b[,1:3]
UL_study1 <- cbind(mUL1,UL1c,nUL1c)

UL_study1$FoldChange_MedianArray_UL1_to_nonUL1 <- FC

UL_study1b <- UL_study1 %>% select(GENE_SYMBOL,SEQUENCE,CYTOBAND,
                                   FoldChange_MedianArray_UL1_to_nonUL1,
                                   UL1_MedianArray,nonUL1_MedianArray,
                                   everything())
```


There are some missing values in the GENE_SYMBOL, SEQUENCE, and CYTOBAND fields, but we don't need to omit them yet.
```{r, eval=FALSE}
colSums(is.na(UL_study1b))
```
The above shows that there aren't any missing values in the samples or the sequence fields, but there are some in the gene symbol, chromosome, and cytoband fields.

Lets get the CNVs of the genes now, but remove the NAs from the Symbol field first.
```{r, eval=FALSE}
UL_study1b2 <- UL_study1b[complete.cases(UL_study1b$GENE_SYMBOL),]

UL_study1_cnv <- UL_study1b2 %>%
  group_by(GENE_SYMBOL) %>%
  mutate(GENE_SYMBOL_CNVs = n()) %>%
  select(GENE_SYMBOL,GENE_SYMBOL_CNVs,everything()) %>%
  ungroup() %>%
  unique()
```

Lets look at what we have for our first few fields and the values.
```{r, eval=FALSE}
head(UL_study1_cnv[,1:6])
```

This is going to grab our target genes for those genes that have a CNV gene count greater than the top 90th percentile and also is either of the bottom 5th percentile or top 95th percentile for fold change median values of UL to nonUL gene expression values.
```{r, eval=FALSE}
UL_study1_thresholds <- subset(UL_study1_cnv, 
                          UL_study1_cnv$GENE_SYMBOL_CNVs > quantile(UL_study1_cnv$GENE_SYMBOL_CNVs,.9) &
                          (UL_study1_cnv$FoldChange_MedianArray_UL1_to_nonUL1 < 
                            quantile(UL_study1_cnv$FoldChange_MedianArray_UL1_to_nonUL1,.05) |
                          UL_study1_cnv$FoldChange_MedianArray_UL1_to_nonUL1 > 
                            quantile(UL_study1_cnv$FoldChange_MedianArray_UL1_to_nonUL1,.95))
                        )

```


Lets now order this table by CNV and Fold Change values.
```{r, eval=FALSE}
UL_study1_ordered <- UL_study1_thresholds[with(UL_study1_thresholds,
                        order(GENE_SYMBOL_CNVs,FoldChange_MedianArray_UL1_to_nonUL1,
                              decreasing=TRUE)),]
```


Lets take a look at the top few rows and first few columns of this table of threshold value target genes for UL.
```{r, eval=FALSE}
head(UL_study1_ordered[,1:7])
```

The table is ordered by CNVs first then by fold change values within the top CNVs. Lets write this to csv and use it later for our visNetwork. So far, it looks like either the Chromosome or the cytoband could be used for location of the nodes. But we could also group the genes by link to gene disease networks, gene networks, or anything else we get ideas about later. 
```{r, eval=FALSE}
write.csv(UL_study1_ordered,'UL_microarray_thresholds.csv',row.names=FALSE)
```

***
Gastric Stomach Cancer data table.
```{r, eval=FALSE}
GSC <- read.delim('GSE64916_series_matrix.txt', sep='\t', comment.char='!',
                 header=TRUE, na.strings=c('',' ', 'NA'))
head(GSC)
```
These are samples of gastric stomach cancer gene expressions in located peripheral blood. The samples GSM1583284, GSM1583285, GSM1583286, and GSM1583287 are GSC, and the control of this study is from the blood of a person without gastric stomach cancer in GSM1583288.

Lets label these columns to be their sample types.
```{r, eval=FALSE}
colnames(GSC) <- c("ID","GSC1","GSC2","GSC3","GSC4","noGSC_ctrl")
head(GSC)
```


```{r, eval=FALSE}
GSCp <- read.delim('GPL13497-9755.txt', sep='\t',header=TRUE, comment.char='#',
                  na.strings=c('',' ','NA'))
head(GSCp)
```

Lets keep the ID, GENE_SYMBOL, CYTOBAND, and SEQUENCE columns of our platform meta data.
```{r, eval=FALSE}
GSC_P <- GSCp %>% select(ID, GENE_SYMBOL, CYTOBAND, SEQUENCE)
head(GSC_P)
```

Now lets combine the two data tables of sample and meta information.
```{r, eval=FALSE}
GSC2 <- merge(GSC_P, GSC, by.x='ID',by.y='ID')
head(GSC2)
```

We will now remove the NAs from the Gene Symbol field.
```{r, eval=FALSE}
GSC3 <- GSC2[complete.cases(GSC2$GENE_SYMBOL),]
head(GSC3)
```


Lets group by gene and get the count of each gene and attach it to the sequence information.
```{r, eval=FALSE}
GSC4 <- GSC3 %>%
  group_by(GENE_SYMBOL) %>%
  mutate(GENE_CNVs = n()) %>%
  select(GENE_SYMBOL, GENE_CNVs, everything()) %>%
  ungroup() %>%
  unique()

colnames(GSC4)
```

Now, we will add the fold change of median values of the GSC samples to the control sample of a healthy person.
```{r, eval=FALSE}
GSC4$GSC_Median <- apply(GSC4[6:9],1,median)
GSC4$FoldChangeMedian_GSC_to_healthyCtrl <- GSC4$GSC_Median/GSC4$noGSC_ctrl

GSC5 <- GSC4 %>% select(GENE_SYMBOL, GENE_CNVs,-ID,CYTOBAND,SEQUENCE,
                        FoldChangeMedian_GSC_to_healthyCtrl,GSC_Median, GSC1:noGSC_ctrl)
colnames(GSC5)
```

Lets get the subset of GSC that has the genes with a high number of CNVs and a high Fold change by median values. 
```{r, eval=FALSE}
GSC_genes <- subset(GSC5, GSC5$GENE_CNVs > median(GSC5$GENE_CNVs) &
                (GSC5$FoldChangeMedian_GSC_to_healthyCtrl < 
                   quantile(GSC5$FoldChangeMedian_GSC_to_healthyCtrl, 0.05) |
                 GSC5$FoldChangeMedian_GSC_to_healthyCtrl > 
                   quantile(GSC5$FoldChangeMedian_GSC_to_healthyCtrl, 0.95)
                )
             )

length(unique(GSC_genes$GENE_SYMBOL))
```
That is too many genes to make the targeted gastric stomach cancer genes, so we will raise our CNV threshold to the top 99th percentile.
```{r, eval=FALSE}
GSC_genes <- subset(GSC5, GSC5$GENE_CNVs > quantile(GSC5$GENE_CNVs,0.99) &
                (GSC5$FoldChangeMedian_GSC_to_healthyCtrl < 
                   quantile(GSC5$FoldChangeMedian_GSC_to_healthyCtrl, 0.05) |
                 GSC5$FoldChangeMedian_GSC_to_healthyCtrl > 
                   quantile(GSC5$FoldChangeMedian_GSC_to_healthyCtrl, 0.95)
                )
             )

length(unique(GSC_genes$GENE_SYMBOL))
```

Lets order this table of targeted genes by CNV count then by decreasing value of fold change from GSC to healthy as a ratio.
```{r, eval=FALSE}
GSC6 <- GSC_genes[with(GSC_genes, order(GENE_CNVs,FoldChangeMedian_GSC_to_healthyCtrl,
                              decreasing=TRUE)),]
head(GSC6)

```


Lets write this file out to csv and work on the other disease data sets separate from this one.
```{r, eval=FALSE}
write.csv(GSC6, 'GastricStomachCancer_Thresholds.csv', row.names=FALSE)
```

***
Colon cancer data table.
```{r, eval=FALSE}
CC <- read.delim('GSE135749_series_matrix.txt', sep='\t', comment.char='!',
                 header=TRUE, na.strings=c('',' ', 'NA'))
head(CC)
```

```{r, eval=FALSE}
CCp <- read.delim('GPL10558-50081.txt', sep='\t',header=TRUE, comment.char='#',
                  na.strings=c('',' ','NA'))
head(CCp)
```


```{r, eval=FALSE}
colnames(CC)
```


```{r, eval=FALSE}
colnames(CCp)
```

Keep only the SYMBOL, ID, Cytoband, and SEQUENCE columns of the CC platform to combine with the CC samples by ID_REF.
```{r, eval=FALSE}
CC_p <- CCp %>% select(ID, Symbol,SEQUENCE,Cytoband)
```

The CC data set will be produced by this next command.
```{r, eval=FALSE}
CC_1 <- merge(CC_p,CC, by.x='ID', by.y='ID_REF')
head(CC_1)
```
Note: Since these are quantile normalized, and there are various ways and reasons to do this, but the purpose being primarily to eliminate noise, we will keep the values, for our purposes, we are still getting those threshold genes that are in the bottom 5th and top 95th percentile while also having more CNVs than the median CNVs of all genes in this set.

We should separate the columns that are samples of colon cancer tumors without treatment of the short hairpin RNAs (shRNA) targeting two different RNAs of LGR5. The first sample columns are the control colon cancer samples, the next two are the first type of LGR5 being knocked down with a shRNA, and the last two samples as columns are the 2nd type of LGR5 being knocked down with the 2nd type of shRNA.

These are colon cancer tumor cells. with two replicates of each sample type or group. We will prepend cc0, cc1,cc2 to these 6 samples for if no shRNA knockdown (cc0), the 1st type shRNA (cc1), or the 2nd type shRNA (cc2) is what the sample is a product of procedure type.
```{r, eval=FALSE}
colnames(CC_1)[5:6] <- paste('cc0', colnames(CC_1)[5:6],sep='_')
colnames(CC_1)[7:8] <- paste('cc1', colnames(CC_1)[7:8],sep='_')
colnames(CC_1)[9:10] <- paste('cc2', colnames(CC_1)[9:10],sep='_')
```

```{r, eval=FALSE}
colnames(CC_1)
```

Now, lets add in the median values of the samples of these three groups of control, knockdown 1, and knockdown 2. The median values will be knockdown 1 compared to control, and knockdown 2 compared to control.We want to be consistent with the methods of our other disease type sample extraction of target genes, so even though there are only two samples of each group, the median is used. Notice the median seems to be programmed to be the mean when there are only two samples.
```{r, eval=FALSE}
cc0 <- apply(CC_1[5:6],1,median)
cc1 <- apply(CC_1[7:8],1,median)
cc2 <- apply(CC_1[9:10],1,median)

FoldChange_CC1_to_CC0 <- cc1/cc0
FoldChange_CC2_to_CC0 <- cc2/cc0
```

Add these median and fold change values to our colon cancer table, CC_1.
```{r, eval=FALSE}
CC_1$ctrl_CC_median <- cc0
CC_1$group1_CC_median <- cc1
CC_1$group2_CC_median <- cc2
CC_1$FoldChange_CC1_to_CC0 <- FoldChange_CC1_to_CC0
CC_1$FoldChange_CC2_to_CC0 <- FoldChange_CC2_to_CC0

colnames(CC_1)
```

Rearrange the columns to see the stats and meta information before the sample information.
```{r, eval=FALSE}
CC2 <- CC_1 %>% select(ID:Cytoband, FoldChange_CC1_to_CC0:FoldChange_CC2_to_CC0,
                       ctrl_CC_median:group2_CC_median,everything())
colnames(CC2)
```

Lets group by gene and get the count of each gene and attach it to the sequence information.
```{r, eval=FALSE}
CC3 <- CC2[complete.cases(CC2$Symbol),]

CC4 <- CC3 %>%
  group_by(Symbol) %>%
  mutate(Symbol_CC_CNVs = n()) %>%
  select(Symbol, Symbol_CC_CNVs, everything()) %>%
  ungroup() %>%
  unique()
```

Now, lets get our threshold values so that the genes with CNVs greater than the median value of CNVs of genes in our data set are selected and also those genes in that group but also having a threshold of being in the bottom 5th and top 95th percentile for fold change values of group1/control and group2/control are selected as target genes.
```{r, eval=FALSE}
CC5 <- subset(CC4, 
              (CC4$Symbol_CC_CNVs > median(CC4$Symbol_CC_CNVs)) &
               (CC4$FoldChange_CC1_to_CC0 < quantile(CC4$FoldChange_CC1_to_CC0,.05, na.rm=TRUE) 
               | 
                CC4$FoldChange_CC1_to_CC0 > quantile(CC4$FoldChange_CC1_to_CC0,.95, na.rm=TRUE)
               )
              |  
              (CC4$Symbol_CC_CNVs > median(CC4$Symbol_CC_CNVs))  
               &            
              (CC4$FoldChange_CC2_to_CC0 < quantile(CC4$FoldChange_CC2_to_CC0,.05, na.rm=TRUE) 
               |               
               CC4$FoldChange_CC2_to_CC0 > quantile(CC4$FoldChange_CC2_to_CC0,.95, na.rm=TRUE)) 
              )
```

There are a lot of observations for this threshold dataset of targeted colon cancer genes. Lets see how many genes are unique.
```{r, eval=FALSE}
length(unique(CC5$Symbol))
```
That is a lot of genes as gene targets, so lets set a higher threshold for the genes with CNVs higher than the 97th percentile.
```{r, eval=FALSE}
CC6 <- subset(CC4, 
              (CC4$Symbol_CC_CNVs > quantile(CC4$Symbol_CC_CNVs,.97)) &
               (CC4$FoldChange_CC1_to_CC0 < quantile(CC4$FoldChange_CC1_to_CC0,.05, na.rm=TRUE) 
               | 
                CC4$FoldChange_CC1_to_CC0 > quantile(CC4$FoldChange_CC1_to_CC0,.95, na.rm=TRUE)
               )
              |  
              (CC4$Symbol_CC_CNVs > quantile(CC4$Symbol_CC_CNVs,.97))  
               &            
              (CC4$FoldChange_CC2_to_CC0 < quantile(CC4$FoldChange_CC2_to_CC0,.05, na.rm=TRUE) 
               |               
               CC4$FoldChange_CC2_to_CC0 > quantile(CC4$FoldChange_CC2_to_CC0,.95, na.rm=TRUE)) 
              )
```

This dataset is much better to work with for targeted genes based on our set threshold limits as discriminates. Lets see how many are unique.
```{r, eval=FALSE}
length(CC6$Symbol)
```

Lets order this data table by CNVs then by fold change decreasing by group1 then by group2. 
```{r, eval=FALSE}
CC7 <- CC6[with(CC6, order(Symbol_CC_CNVs,FoldChange_CC1_to_CC0,
                           FoldChange_CC2_to_CC0, decreasing=TRUE)),]
```


If we can't get the CYTOBAND for the other diseases then we will leave it out or add it in later if there are few to look up and add manually.
Lets write this file out to csv and work on the other disease data sets separate from this one.
```{r, eval=FALSE}
write.csv(CC7, 'ColonCancerThresholds.csv', row.names=FALSE)
```

***
Pancreatic cancer data table.
```{r, eval=FALSE}
PC <- read.delim('GSE131859_non-normalized.txt', sep='\t', comment.char='!',
                 header=TRUE, na.strings=c('',' ', 'NA'))
head(PC)
```

```{r, eval=FALSE}
PCp <- read.delim('GPL14951-11332.txt', sep='\t',header=TRUE, comment.char='#',
                  na.strings=c('',' ','NA'))
head(PCp)
```


```{r, eval=FALSE}
colnames(PC)
```

These samples have the pvalue scores attached to the sample microarray readings. We aren't interested in these pval fields, so we will remove them and the added X field when loading of the row numbers when saved to csv from other file.
```{r, eval=FALSE}
PC1 <- PC %>% select(-MiaPACA2_EV.Detection_Pval,-MiaPACA2_ARHGEF10.Detection_Pval,
                     -Hs766T_shGFP.Detection_Pval,-Hs766T_shARHGEF10.Detection_Pval,-X)
head(PC1)
```

We have four samples of pancreatic cancer. MiaPACA2_EV is the control of pancreatic cancer epithelial cells. The idea is to show that ARHGEF10 is a tumor suppressor by examining two cell lines of available commercial pancreatic cancer cells where MiaPACA2 is directly from the epithelial pancreatic cells and Hs766T are from the lymph nodes of someone with pancreatic cancer. MiaPACA2_ARHGEF10 sample is when ARHGEF10 is overexpressed to demonstrate suppression of pancreatic cancer cells not mutating. The Hs766T_shGFP is the sample where the short hair pin RNA additive to eliminate the tumor suppressor ARHGEF10 wasn't added and is the lymph node pancreatic cancer control. The Hs766T_shARHGEF10 is when the Hs766T cell line of pancreatic cancer cells had the ARHGEF10 gene knocked down or suppressed. Lets rename these column samples by what they are,

```{r, eval=FALSE}
colnames(PC1) <- c('ID_REF','PC_epithelial_ctrl','PC_epithelial_SuppressorAdded',
                   'PC_lymph_ctrl','PC_lymph_SuppressorKnockedOut')

```


```{r, eval=FALSE}
colnames(PCp)
```

Keep only the Symbol, Cytoband, ID, and SEQUENCE columns of the PC platform to combine with the PC samples by ID_REF and GENE_SYMBOL.
```{r, eval=FALSE}
PC_p <- PCp %>% select(ID, Symbol, SEQUENCE, Cytoband)
head(PC_p)
```

The PC data set will be produced by this next chunk.
```{r, eval=FALSE}
PC2 <- merge(PC_p,PC1, by.x='ID', by.y='ID_REF')
head(PC2)
```

Since there is only one sample of each, it is redundant to get the median of each type, so we will get the fold change values of the suppresor added epithelial PC cells to the epithelial PC cells control, and the fold change values of the lymph node PC cells with the suppressor knocked out or suppressed to the lymph node PC cells control.
```{r, eval=FALSE}
FC_epithelial_PC <- PC2$PC_epithelial_SuppressorAdded/PC2$PC_epithelial_ctrl
FC_lymphNode_PC <- PC2$PC_lymph_SuppressorKnockedOut/PC2$PC_lymph_ctrl

PC2$FC_epithelial_PC <- FC_epithelial_PC
PC2$FC_lymphNode_PC <- FC_lymphNode_PC

PC3 <- PC2 %>% select(ID:Cytoband, FC_epithelial_PC,FC_lymphNode_PC, everything())
```


Lets group by gene and get the count of each gene and attach it to the sequence information.
```{r, eval=FALSE}
PC4 <- PC3 %>%
  group_by(Symbol) %>%
  mutate(GENE_CNVs = n()) %>%
  select(Symbol, GENE_CNVs, everything()) %>%
  ungroup() %>%
  unique()

colnames(PC4) <- gsub('FC_','FoldChange_', colnames(PC4))
colnames(PC4)
```


```{r, eval=FALSE}
PC5 <- PC4[with(PC4, order(GENE_CNVs, FoldChange_epithelial_PC, 
                                        FoldChange_lymphNode_PC, decreasing=TRUE)),]
```

Get the subset of AD that has the genes with a high number of CNVs and a high Fold change by median values. 
```{r, eval=FALSE}
PC_genes <- subset(PC5, PC5$GENE_CNVs > median(PC5$GENE_CNVs, na.rm=TRUE) &
                    (PC5$FoldChange_epithelial_PC < 
                       quantile(PC5$FoldChange_epithelial_PC,0.05, na.rm=TRUE) |
                    PC5$FoldChange_lymphNode_PC > 
                      quantile(PC5$FoldChange_lymphNode_PC, .95, na.rm=TRUE))
                  )

length(unique(PC_genes))

```
This is a lot of unique genes, so lets filter more by making the CNVs to be in the top 95th percentile of CNV counts instead of greater than the median of gene CNVs.
```{r, eval=FALSE}
PC_genes2 <- subset(PC5, PC5$GENE_CNVs > quantile(PC5$GENE_CNVs, 0.95,na.rm=TRUE) &
                    (PC5$FoldChange_epithelial_PC < 
                       quantile(PC5$FoldChange_epithelial_PC,0.05, na.rm=TRUE) |
                    PC5$FoldChange_lymphNode_PC > 
                      quantile(PC5$FoldChange_lymphNode_PC, .95, na.rm=TRUE))
                  )
length(unique(PC_genes2))

```
That is a much better quantity to work with for targeted Pancreatic Cancer genes. Lets order this by CNVs then by fold change epithelial then fold change lymph.
```{r, eval=FALSE}
PC6 <- PC_genes2[with(PC_genes2, order(GENE_CNVs,FoldChange_epithelial_PC,
                                       FoldChange_lymphNode_PC, decreasing=TRUE)),]
head(PC6)
```

Lets drop the ID field. 
```{r, eval=FALSE}
PC7 <- PC6 %>% select(-ID)
head(PC7)
```

Lets write this file out to csv and work on the other disease data sets separate from this one.
```{r, eval=FALSE}
write.csv(PC7, 'Pancreatic_Cancer_Thresholds.csv', row.names=FALSE)
```

***
Alzheimer's Disease data table.
```{r, eval=FALSE}
AD <- read.delim('GSE109887_series_matrix.txt', sep='\t', comment.char='!',
                 header=TRUE, na.strings=c('',' ', 'NA'))
head(AD)
```

```{r, eval=FALSE}
ADp <- read.delim('GPL4133-12599.txt', sep='\t',header=TRUE, comment.char='#',
                  na.strings=c('',' ','NA'))
head(ADp)
```


```{r, eval=FALSE}
colnames(AD)
```


```{r, eval=FALSE}
colnames(ADp)
```

Keep only the GENE_SYMBOL and SEQUENCE columns of the AD platform to combine with the AD samples by ID_REF and GENE_SYMBOL.
```{r, eval=FALSE}
AD_p <- ADp[,c(10,20)]
```

The AD data set will be produced by this next chunk.
```{r, eval=FALSE}
AD_1 <- merge(AD_p,AD, by.x='GENE_SYMBOL', by.y='ID_REF')
head(AD_1)
```

We should separate the columns that are samples of AD patients to those that are the control samples of AD patients.
```{r, eval=FALSE}
metaAD <- read.csv('AlzheimerAgeGenderTissueSamplesMeta.csv',sep=',', header=TRUE,
                   na.strings=c('',' ','NA'))
head(metaAD)
```


```{r, eval=FALSE}
row.names(metaAD) <- metaAD$sampleID
```


```{r, eval=FALSE}
meta_AD <- as.data.frame(t(metaAD))
head(meta_AD)
```

Get the indices of the AD and control patients
```{r, eval=FALSE}
ad <- grep('AD', meta_AD$disease)
#add 1 because of the additional sequence field in AD_1 not in metaAD
ad <- ad+1
```

Paste the type of sample to the sample ID fields.
```{r, eval=FALSE}
colnames(AD_1)[ad] <- paste('AD',colnames(AD_1)[ad],sep='_')
colnames(AD_1)[-c(1,2,ad)] <- paste('ctrl_AD',colnames(AD_1)[-c(1,2,ad)], sep='_')
```

Create separate tables for the AD and the control patients.
```{r, eval=FALSE}
ad1 <- AD_1[,ad]
ctrl_ad1 <- AD_1[,-c(1,2,ad)]
```


Row Means of each subset.
```{r, eval=FALSE}
ad1$Mean_AD <- rowMeans(ad1)
ctrl_ad1$Mean_ctrl_AD <- rowMeans(ctrl_ad1)
```


```{r, eval=FALSE}
ad1$Median_AD <- apply(ad1,1,median)
ctrl_ad1$Median_ctrl_AD <- apply(ctrl_ad1,1,median)
```

Now combine these new value fields to the original table for AD and control mean and median.
```{r, eval=FALSE}
AD_1$Mean_AD <- ad1$Mean_AD
AD_1$Mean_ctrl_AD <- ctrl_ad1$Mean_ctrl_AD
AD_1$Median_AD <- ad1$Median_AD
AD_1$Median_ctrl_AD <- ctrl_ad1$Median_ctrl_AD
```

Remove duplicate entries, the genes even thought they have different sequence values, are showing duplicate or identical gene expression values by gene.
```{r, eval=FALSE}
AD2 <- AD_1[!duplicated(AD_1),]

AD2$FoldChange_Mean_AD_2_ctrl <- AD2$Mean_AD/AD2$Mean_ctrl_AD
AD2$FoldChange_Median_AD_2_ctrl <- AD2$Median_AD/AD2$Median_ctrl_AD

head(AD2)[,c(1,2,83:86)]
```
You can see from the above table that even though the sequence is different in these first displayed genes that the gene the sequences belong to have the same gene expression values. 

Lets group by gene and get the count of each gene and attach it to the sequence information.
```{r, eval=FALSE}
AD3 <- AD2 %>%
  group_by(GENE_SYMBOL) %>%
  mutate(GENE_CNVs = n()) %>%
  select(GENE_SYMBOL, GENE_CNVs, SEQUENCE, Median_AD, Median_ctrl_AD, 
         FoldChange_Mean_AD_2_ctrl, FoldChange_Median_AD_2_ctrl, everything()) %>%
  ungroup() %>%
  unique()
```


```{r, eval=FALSE}
Alzheimer <- AD3[with(AD3, order(GENE_CNVs, GENE_SYMBOL,  decreasing=TRUE)),]
```

Get the subset of AD that has the genes with a high number of CNVs and a high Fold change by median values. 
```{r, eval=FALSE}
AD_genes <- subset(Alzheimer, Alzheimer$GENE_CNVs > median(Alzheimer$GENE_CNVs) &
                              (Alzheimer$FoldChange_Median_AD_2_ctrl < 0.90 |
                              Alzheimer$FoldChange_Median_AD_2_ctrl > 1.10)
                  )
alz_genes <- unique(AD_genes$GENE_SYMBOL)
alz_genes
```


```{r, eval=FALSE}
AD4 <- AD_genes[,c(1:3,7)]
AD4
```

```{r, eval=FALSE}
AD_genes1 <- datatable(data=AD4,  rownames=FALSE,
                      extensions=c('Buttons','Responsive','FixedColumns'),
                      filter=list(position='top'),
                      options=list(
                        dom='Bfrtip',scrollX = TRUE, fixedColumns = TRUE,
                        buttons=c('colvis','csv'),
                        language=list(sSearch='Filter:')
                        )
                      )

AD_genes1
```

Lets also add in the cytoband location.
```{r, eval=FALSE}
cyto <- ADp %>% select(GENE_SYMBOL, CYTOBAND) 
AD5 <- merge(cyto, AD4, by.x='GENE_SYMBOL', by.y='GENE_SYMBOL')
head(AD5)
```

So, now we have our table of Alzheimer genes that have high CNVs and Fold Change Median values. Lets start getting this information for the other diseases to word towards building our visNetwork of genes related to other genes if any are.

We want to get these same values exactly as we have for the Alzheimer's Disease genes.
```{r, eval=FALSE}
colnames(AD5)
```
If we can't get the CYTOBAND for the other diseases then we will leave it out.
Lets write this file out to csv and work on the other disease data sets separate from this one.
```{r, eval=FALSE}
write.csv(AD5, 'useableAlzheimerStats.csv', row.names=FALSE)
```

***
***
***

%^&
!!!THE BEGINNING of our VISNETWORK!!!

Lets start by reading in those data tables we will be working with that derived the genes in the highes percentile of Copy Number Variants of genes as well as being in the bottom 5th and top 90th-99th percentiles of fold change values. The library visNetwork requires that there be an edges and a nodes data file to read from and that there be certain specific columns within each table, such as ID, to, from, label, and so on. How we will link the genes is by their ID and to see if that ID links to any other gene in our tables of disease genes. We will first read in our tables, then make sure the column names describe what disease the fold change values and CNVs are for, as well as add a field to each of these targeted genes tables that identifies the gene as being a top gene related to the disease table. Such as, pancreatic cancer, beadchip benign uterine leiomyoma, microarray benign uterine leiomyoma, gastric stomach cancer, colon cancer, or Alzheimer's Disease.

```{r}
pancreatic <- read.csv('Pancreatic_Cancer_Thresholds.csv',sep=',', header=TRUE,
                       na.strings=c('',' ','NA'))
colon <- read.csv('ColonCancerThresholds.csv',sep=',', header=TRUE,
                  na.strings=c('',' ','NA')) 
stomach <-  read.csv('GastricStomachCancer_Thresholds.csv',sep=',', header=TRUE, 
                     na.strings=c('',' ','NA'))
alzheimer <- read.csv('useableAlzheimerStats.csv',sep=',', header=TRUE,
                      na.strings=c('',' ','NA'))
ul_beadchip <- read.csv('UL_study1_thresholds.csv',sep=',', header=TRUE, 
                        na.strings=c('',' ','NA'))
ul_microarray <- read.csv('UL_microarray_thresholds.csv',sep=',', header=TRUE, 
                          na.strings=c('',' ','NA'))

```

Lets now look at each of these six diseases and add in what type of disease it is to the fields in each table that don't give that information.
```{r}
colnames(alzheimer)[1:4] <- paste('AD',colnames(alzheimer)[1:4],sep='_')

colnames(colon)[c(1,3,4,5)] <- paste('CC',colnames(colon)[c(1,3,4,5)],sep='_')

colnames(stomach)[1:4] <- paste('GSC', colnames(stomach)[1:4],sep='_')

colnames(pancreatic)[1:4] <- paste('PC', colnames(pancreatic)[1:4], sep='_')

colnames(ul_beadchip)[1:5] <- paste('UL_beadchip', colnames(ul_beadchip)[1:5], sep='_')
colnames(ul_beadchip)[9:46] <- gsub('UL','UL_beadchip', colnames(ul_beadchip)[9:46])

colnames(ul_microarray)[c(1:4)] <- paste('UL_array', colnames(ul_microarray)[c(1:4)],
                                              sep='_')
colnames(ul_microarray)[8:13] <- gsub('UL_','UL_microarray_', colnames(ul_microarray)[8:13])
```


